%
% Copyright 2014, General Dynamics C4 Systems
%
% This software may be distributed and modified according to the terms of
% the GNU General Public License version 2. Note that NO WARRANTY is provided.
% See "LICENSE_GPLv2.txt" for details.
%
% @TAG(GD_GPL)
%

\chapter{\label{ch:vspace}Address Spaces and Virtual Memory}

A virtual address space in seL4 is called a VSpace. In a similar
way to a CSpace (see \autoref{ch:cspace}), a VSpace is composed of objects 
provided by the microkernel. Unlike CSpaces, these objects for managing
virtual memory largely correspond to those of the hardware;
that is, a page directory pointing to page tables, which in turn map
physical frames.  The kernel also includes \obj{ASID Pool} and
\obj{ASID Control} objects for tracking the status of address spaces.

These VSpace-related objects are sufficient to implement the
hardware data structures required to create, manipulate, and destroy
virtual memory address spaces. It should be noted that, as usual, the
manipulator of a virtual memory space needs the appropriate
capabilities to the required objects.

\section{Overview}
\ifxeightsix
\paragraph{IA-32}

IA-32 processors have a two-level page-table structure.
The top-level page directory covers a 4\,GiB range and each page table covers a 4\,MiB range.
Frames can be 4\,KiB or 4\,MiB.
Before a 4\,KiB
frame can be mapped, a page table covering the range that the frame will
be mapped into must have been mapped, otherwise seL4 will return an
error.
4\,MiB frames are mapped directly into the page directory, thus,
a page table does not need to be mapped first.
\fi

\paragraph{ARM}

ARM processors \ifxeightsix{also }\fi have a two-level page-table structure.
The top-level page directory covers a range of 4\,GiB and each page table covers a 1\,MiB range.
Four page sizes are allowed: 4\,KiB, 64\,KiB, 1\,MiB and 16\,MiB.
4\,KiB and 64\,KiB pages are mapped into the second-level page table.
Before
they can be mapped, a page table covering the range that they will be
mapped into must have been installed.
1\,MiB and 16\,MiB pages are installed directly into the page directory such that it is not necessary to map a page table first.
Pages of 4\,KiB and 1\,MiB size occupy one slot in a page table and the page directory, respectively.
Pages of 64\,KiB and 16\,MiB size occupy 16 slots in a page table and the page directory, respectively.

\paragraph{RISC-V}

The RISC-V architecture has a configurable number of page-table levels. Configuration settings
make appropriate page sizes available. On RISC-V, each page-table level, including the top level, is
the same object, a page table object.

\section{Objects}

\paragraph{\obj{Page Directory}}

The \obj{Page Directory} (PD) is the top-level page table of the 
two-level page table structure. It has a hardware-defined format, but
conceptually contains a number of page directory entries (PDEs).
On x86, the \obj{Page Directory} has no invocations itself, but it is used
as an argument to several other virtual-memory related object invocations.

On ARM, the highest level page directory (\obj{Page Directory} on aarch32 and global page directory on
aarch64) objects possess a few invocations for the user to do cache maintenance
operations:



By making these cache related operations invocations on page directory capabilities in addition to
the page capabilities themselves, the
API allows users more flexible policy options. For example, a process that has delegated a page
directory can conduct cache operations on all frames mapped from that capability without access
to those capabilities directly.

\paragraph{\obj{Page Table}} The \obj{Page Table} (PT) object forms the
second level of the page-table structure.
It contains a number of slots, each of which contains a page-table entry (PTE).
\paragraph{\obj{Page}}
A \obj{Page} object corresponds to a frame of physical memory that is used to
implement virtual memory pages in a virtual address space.

The virtual address for a \obj{Page} mapping
must be aligned to
the size of the \obj{Page} and must be mapped to a suitable \obj{Page Directory}
or \obj{Page Table}. To map a page readable, the capability
to the page
that is being invoked must have read permissions. To map the page
writable, the capability must have write permissions. The requested
mapping permissions are specified with an argument of type
\texttt{seL4\_CapRights} given to the \apifunc{seL4\_ARM\_Page\_Map}{arm_page_map} \ifxeightsix or \apifunc{seL4\_x86\_Page\_Map}{x86_page_map} \fi method.
\texttt{seL4\_CanRead} and \texttt{seL4\_CanWrite} are the only valid
permissions on \ifxeightsix both \else the \fi ARM \ifxeightsix and IA-32 \fi architecture\ifxeightsix{s}\fi. If the capability does not have
sufficient permissions to authorise the given mapping, then
the mapping permissions are silently downgraded.

\paragraph{\obj{ASID Control}}

For internal kernel book-keeping purposes, there is a fixed maximum
number of applications the system can support.  In order to manage
this limited resource, the microkernel provides an \obj{ASID Control}
capability. The \obj{ASID Control} capability is used to generate a
capability that authorises the use of a subset of available address-space identifiers.
This newly created capability is called an
\obj{ASID Pool}. \obj{ASID Control} only has a single \texttt{MakePool} method for each
architecture, listed in the table below.

\begin{tabularx}{\textwidth}{Xl} \toprule
\emph{Architectures} & \emph{Methods} \\ \midrule
IA32, X64            & \autoref{group__x86__seL4__X86__ASIDControl} \\
AArch32, AArch64     & \autoref{group__arm__seL4__ARM__ASIDControl} \\
RISC-V               & \autoref{group__riscv__seL4__RISCV__ASIDControl} \\
\bottomrule
\end{tabularx}

\subsection{ASID Pool}

An \obj{ASID Pool} confers the right to create a subset of the available
maximum applications. For a VSpace to be usable by an application, it
must be assigned to an ASID. This is done using a capability to an
\obj{ASID Pool}. The \obj{ASID Pool} object has a single method, \texttt{Assign}, for each
architecture:

\begin{tabularx}{\textwidth}{Xl} \toprule
\emph{Architectures} & \emph{Methods} \\ \midrule
IA32, X64            & \autoref{group__x86__seL4__X86__ASIDPool} \\
AArch32, AArch64     & \autoref{group__arm__seL4__ARM__ASIDPool} \\
RISC-V               & \autoref{group__riscv__seL4__RISCV__ASIDPool} \\
\bottomrule
\end{tabularx}

\section{Mapping Attributes}
A parameter of type \texttt{seL4\_ARM\_VMAttributes} or
\texttt{seL4\_x86\_VMAttributes} is used to specify the cache behaviour of the
page being mapped; possible values for ARM that can be bitwise OR'd together are
shown in \autoref{tbl:vmattr_arm} \ifxeightsix and an enumeration of valid values
for IA-32 are shown in \autoref{tbl:vmattr_ia32}\fi.

\begin{table}[htb]
  \begin{center}
    \begin{tabularx}{\textwidth}{p{0.33\textwidth}X}
      \toprule
      Attribute & Meaning \\
      \midrule
      \texttt{seL4\_ARM\_PageCacheable} & Enable data in this mapping
      to be cached \\
      \texttt{seL4\_ARM\_ParityEnabled} & Enable parity checking for
      this mapping\\
      \texttt{seL4\_ARM\_ExecuteNever} & Map this memory as non-executable \\
      \bottomrule
    \end{tabularx}
    \caption{\label{tbl:vmattr_arm} Virtual memory attributes for ARM page
      table entries.}
  \end{center}
\end{table}

\begin{table}[htb]
  \begin{center}
    \begin{tabularx}{\textwidth}{p{0.33\textwidth}X}
      \toprule
      Attribute & Meaning \\
      \midrule
      \texttt{seL4\_x86\_WriteBack} & Read and writes are cached \\
      \texttt{seL4\_x86\_CacheDisabled} & Prevent data in this mapping
      from being cached \\
      \texttt{seL4\_x86\_WriteThrough} & Enable write through cacheing for this mapping \\
      \texttt{seL4\_x86\_WriteCombining} & Enable write combining for this mapping \\
      \bottomrule
    \end{tabularx}
    \caption{\label{tbl:vmattr_ia32} Virtual memory attributes for x86 page
      table entries.}
  \end{center}
\end{table}

\section{Sharing Memory}

seL4 does not allow \obj{Page Table}s to be shared, but does allow
pages to be shared between address spaces. 
To share a page, the capability to the 
\obj{Page} must first be
duplicated using the \apifunc{seL4\_CNode\_Copy}{cnode_copy} method and the new copy must
be used in the \apifunc{seL4\_ARM\_Page\_Map}{arm_page_map} \ifxeightsix or \apifunc{seL4\_x86\_Page\_Map}{x86_page_map} \fi method that maps the page into the second
address space. Attempting to map the same capability
twice will result in an error. 


\section{Page Faults}

Page faults are reported to the exception handler of the executed thread.
See \autoref{sec:vm-fault}.
